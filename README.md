[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=16974069&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

# Part 1: Introduction to Software Engineering

### Explain what software engineering is and discuss its importance in the technology industry.
. Software engineering is the systematic approach to the design, development, testing, and maintenance of software systems. It applies engineering principles to software development to create reliable, efficient, and high-quality software that meets user needs. Software engineering encompasses a variety of practices, including requirements analysis, software design, coding, testing, and deployment, as well as maintenance and support.
 importance of software Engineering
Ensures Quality and Reliability: Structured software engineering practices help ensure that software systems are reliable, safe, and meet quality standards. High-quality software is crucial in many sectors, especially those that depend on accuracy and security, such as healthcare, finance, and aerospace.

Promotes Efficiency and Cost-Effectiveness: Using engineering principles to structure development leads to better-organized code and more efficient processes. This reduces development time and long-term maintenance costs by minimizing errors and increasing the reusability of code.

Supports Scalability and Flexibility: Good software engineering practices make it easier to scale software as needs grow or change, ensuring that the software can adapt to new requirements or environments with minimal disruption.

Enables Innovation: By providing structured approaches to development, software engineering allows developers to focus on innovation. Techniques like modular design and testing enable new features and technologies to be incorporated more rapidly and safely.

Enhances Security: Security practices in software engineering, such as secure coding standards and vulnerability testing, help protect users and companies from cyber threats, which is increasingly important as data privacy regulations become stricter.

Improves Collaboration and Communication: Software engineering encourages collaboration and standardization, helping teams of developers, designers, and stakeholders to work effectively together on complex projects. This is especially critical for large-scale projects where multiple teams are involved.

### Identify and describe at least three key milestones in the evolution of software engineering.
. Structured Programming (1960s–1970s)
Description: Structured programming emerged in the 1960s as a response to the challenges of "spaghetti code," where programs lacked organization, making them difficult to understand and maintain. The structured programming paradigm introduced the use of control structures like loops, conditionals, and subroutines, encouraging a clear, linear flow of control.

Impact: This milestone emphasized code readability and logical flow, which reduced complexity and improved maintainability. Programming languages such as Pascal and C incorporated structured programming principles, enabling developers to write cleaner and more efficient code. Structured programming laid the groundwork for disciplined coding practices and served as a foundation for more advanced methodologies.

2. Object-Oriented Programming (1980s)
Description: Object-oriented programming (OOP) became widely popular in the 1980s as a way to structure software around "objects"—data encapsulated with functions that operate on the data. Key principles of OOP include encapsulation, inheritance, and polymorphism, which allow for modularity and reusability. Languages like C++ and later Java were designed around OOP concepts.

Impact: OOP allowed developers to create more modular and reusable code, where components could be developed independently and then integrated. This helped manage the complexity of larger systems, as well-organized code made it easier to scale projects and adapt to new requirements. OOP remains a cornerstone of modern software engineering, especially in fields like web development, game design, and enterprise software.

3. Agile Methodologies (2000s)
Description: Agile methodologies arose in the early 2000s as a reaction to the limitations of traditional, linear development models like the Waterfall model, which often struggled to adapt to changing requirements. The Agile Manifesto, published in 2001, emphasized principles like customer collaboration, flexibility, and iterative development. Methodologies such as Scrum and Kanban became popular frameworks within the Agile movement.

Impact: Agile transformed software engineering by promoting continuous feedback, collaboration, and rapid iteration. It allowed teams to quickly respond to changes, making software development more flexible and aligned with user needs. Agile has become the dominant approach in software development, especially for startups and tech companies that value adaptability and speed. Agile’s iterative and collaborative nature also influenced DevOps, which integrates development and operations for faster deployment cycles.


### List and briefly explain the phases of the Software Development Life Cycle.
. 1. Planning
Objective: Define the project's scope, objectives, resources, timeline, and budget.
Description: This phase involves gathering input from stakeholders, analyzing project feasibility, and creating a detailed project plan. It sets the groundwork for successful project execution and ensures all stakeholders have a shared understanding.
2. Requirements Analysis
Objective: Determine and document functional and non-functional requirements for the software.
Description: Analysts work with stakeholders to understand what the software should accomplish. This includes defining features, security needs, performance requirements, and any compliance needs. The outcome is a Software Requirements Specification (SRS) document.
3. Design
Objective: Create a blueprint for building the software.
Description: The design phase involves both high-level architectural design and detailed component design. Developers decide on aspects like system architecture, database design, user interfaces, and technology stack. The design document serves as a reference for the development team.
4. Development (Implementation)
Objective: Build the software based on design specifications.
Description: Developers write and compile the code, creating individual components and integrating them. This phase often involves programming, version control, and collaboration among team members. The outcome is a functional version of the software.
5. Testing
Objective: Ensure the software is functional, reliable, and meets requirements.
Description: Testers identify and fix bugs through various types of testing, such as unit testing, integration testing, system testing, and user acceptance testing (UAT). This phase is crucial to validate the software’s quality before release.
6. Deployment
Objective: Release the software to the users or production environment.
Description: Once tested, the software is deployed for use. This phase may involve installation, data migration, and user training. The deployment can be done in stages, especially for complex or large systems.
7. Maintenance
Objective: Ensure ongoing software performance and address issues as they arise.
Description: Maintenance includes fixing bugs, making updates, and adding new features based on user feedback or evolving requirements. This phase is often the longest and involves regular monitoring, troubleshooting, and improvement.

### Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
. Waterfall Methodology
Characteristics:
Sequential and Linear: Waterfall follows a fixed, sequential progression, with each phase completed before moving to the next.
Rigid Structure: Requirements are gathered upfront, and changes during development are often discouraged.
Documentation-Driven: Heavy emphasis on documentation, which serves as a guide and reference for all phases.
Testing at the End: Testing is typically conducted only after the development phase is complete.
Appropriate Scenarios for Waterfall:
Well-Defined Requirements: Waterfall is ideal when requirements are clear, well-documented, and unlikely to change. For example, it’s suitable for projects where client needs are fixed from the outset.

Regulated Industries: In industries such as healthcare or aerospace, where strict documentation, regulatory compliance, and testing standards are required, Waterfall’s structured, documented approach is beneficial.

Simple or Small-Scale Projects: For projects with a straightforward scope and minimal need for iterative changes, such as creating a utility program or an internal business application with clear specifications, Waterfall can be efficient.

Agile Methodology
Characteristics:
Iterative and Incremental: Agile promotes iterative development, delivering small, functional parts of the software (increments) regularly.
Flexible and Adaptive: Requirements can evolve, and teams adapt quickly to changes, even late in development.
Collaboration-Focused: Agile emphasizes close collaboration with stakeholders and team members, with frequent feedback loops.
Continuous Testing: Testing happens throughout the development process, ensuring issues are identified and resolved early.
Appropriate Scenarios for Agile:
Evolving Requirements: Agile works best when requirements are expected to change or evolve based on user feedback. For example, in startups or app development, Agile allows flexibility to adjust features and priorities as the market or user needs change.

Complex, Large-Scale Projects: For projects with high complexity, such as e-commerce platforms or custom enterprise solutions, Agile’s iterative approach allows teams to manage complexity by breaking down work into manageable sprints.

User-Centric Products: Agile is suitable for projects focused on user experience and rapid feature updates, like social media platforms or mobile applications, where continuous improvements and user feedback are essential.

### Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
. Software Developer
Role: The Software Developer is responsible for writing, debugging, and maintaining code that implements the functionality of the software.

Responsibilities:

Coding and Implementation: Write, review, and debug code to develop features and solve problems, ensuring that the code is efficient and follows best practices.
Requirements Analysis: Collaborate with stakeholders and other team members to understand requirements and translate them into technical solutions.
Unit Testing: Test their code to ensure it functions correctly before passing it on to the QA team.
Code Reviews: Review code written by other developers to maintain code quality and identify potential issues early.
Documentation: Document code functionality, architecture, and solutions for future maintenance and collaboration with other developers.
Maintenance and Bug Fixes: Resolve issues found by QA or reported by users and make necessary updates to keep the software functioning correctly.
Example: In an e-commerce platform project, a developer might create the code to handle user authentication, payment processing, and order management.

2. Quality Assurance (QA) Engineer
Role: The QA Engineer is responsible for ensuring the software meets quality standards and requirements, identifying defects, and verifying that they are fixed.

Responsibilities:

Test Planning and Design: Develop test plans, test cases, and testing strategies that cover all functionalities and possible use cases.
Manual and Automated Testing: Perform both manual and automated tests, including unit, integration, system, and user acceptance testing, to ensure all components work as expected.
Bug Identification and Reporting: Identify issues, document bugs in detail, and communicate them to the development team.
Regression Testing: Verify that previously developed and tested software functions correctly after changes, ensuring new updates do not introduce new issues.
Quality Standards and Compliance: Ensure the software meets quality standards, performance benchmarks, and complies with any relevant regulations.
Collaborate with Developers: Work closely with developers to understand potential issues, retest fixes, and suggest improvements.
Example: For a mobile app, a QA engineer might test the app’s functionality across different devices and operating systems, ensuring compatibility, performance, and a smooth user experience.

3. Project Manager
Role: The Project Manager (PM) is responsible for overseeing the project’s progress, coordinating team efforts, managing resources, and ensuring the project meets its objectives on time and within budget.

Responsibilities:

Project Planning and Scheduling: Create detailed project plans, set timelines, milestones, and assign tasks to ensure project goals are achieved.
Resource Management: Allocate resources effectively and make adjustments based on project needs and constraints, including managing budgets, timelines, and team capacity.
Risk Management: Identify potential risks, develop mitigation strategies, and adapt plans to address any unexpected changes or issues.
Stakeholder Communication: Serve as the primary point of contact between the team and stakeholders, providing regular updates on progress, challenges, and deliverables.
Facilitation and Problem Solving: Facilitate communication among team members, resolve conflicts, and provide guidance to keep the team focused and motivated.
Quality and Scope Management: Ensure that the project stays on track with respect to quality standards, timelines, and scope, managing any requests for scope changes with stakeholders.

### Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
. Integrated Development Environments (IDEs)
Importance: IDEs are comprehensive software applications that provide a complete environment for developers to write, debug, and test code. IDEs streamline the development process by integrating several tools into a single interface, which makes coding faster, more efficient, and less error-prone.

Key Benefits:

Code Writing and Navigation: IDEs provide features like syntax highlighting, code completion, and error checking, which reduce syntax errors and speed up coding. Navigation tools help developers quickly locate functions, classes, and files within large codebases.
Debugging Tools: IDEs come with built-in debuggers that allow developers to set breakpoints, inspect variables, and step through code line by line, making it easier to identify and fix issues.
Integration with Other Tools: IDEs often support integrations with version control systems, build automation tools, and testing frameworks, creating a unified workflow.
Testing and Profiling: Many IDEs include testing tools and performance profilers to identify performance bottlenecks and run unit tests directly within the IDE.
Examples of IDEs:

Visual Studio Code: A lightweight yet powerful IDE popular for web development. It supports numerous extensions for language support, debugging, and integration with other tools like Git.
IntelliJ IDEA: Known for its intelligent code completion and support for Java and other JVM-based languages, it is widely used in enterprise Java development.
PyCharm: A specialized IDE for Python development that includes extensive support for Python libraries, Django for web development, and tools for data science.
Version Control Systems (VCS)
Importance: A VCS is essential for tracking and managing changes to a codebase, allowing multiple developers to collaborate efficiently. Version control provides a history of changes, enabling teams to revert to previous versions, resolve conflicts, and work on features or fixes in parallel.

Key Benefits:

Collaboration: VCS allows multiple developers to work on the same project simultaneously. Branching and merging features help manage parallel workstreams, allowing developers to work on features without affecting the main codebase.
Change Tracking: VCS keeps a record of every change made to the code, including who made it and when. This history is invaluable for understanding the evolution of the project and diagnosing issues.
Rollback Capability: If a change introduces bugs or errors, developers can easily revert to a previous stable version, making it safer to experiment or refactor code.
Backup and Recovery: VCS acts as a central repository, protecting code from accidental loss or damage. Code is stored in remote repositories, allowing it to be restored if local files are lost.
Examples of VCS:

Git: The most widely used VCS, Git allows distributed version control, meaning each user has a full copy of the repository. Platforms like GitHub, GitLab, and Bitbucket provide hosting and collaboration features for Git repositories.
Subversion (SVN): A centralized VCS that keeps the repository on a single server. While not as flexible as Git, SVN is still used in some large organizations and for projects where centralization is preferred.
Mercurial: Similar to Git in its distributed model, Mercurial is known for its simplicity and speed. It’s used in some teams as an alternative to Git but has a smaller adoption rate.
Why IDEs and VCS Are Essential Together
Combining an IDE with a VCS brings powerful advantages to the development process. Many modern IDEs integrate with VCS tools, allowing developers to commit changes, resolve conflicts, and navigate version history directly from the IDE interface. This integration reduces context-switching, streamlines workflows, and helps teams manage code more effectively.

For example, a developer using Visual Studio Code integrated with Git can write code, commit changes, and push updates to a GitHub repository without leaving the IDE. This integrated environment enhances productivity and keeps the development process smooth and organized.

### What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
. 1. Managing Changing Requirements
Challenge: Requirements often change during a project, especially in agile environments where feedback is continuously incorporated. This can lead to scope creep, rework, and missed deadlines.

Strategies:

Adopt Agile Practices: Embrace agile methodologies, which allow flexibility and regular adjustments. Breaking down the project into sprints makes it easier to incorporate changes without disrupting the entire project.
Clear Communication with Stakeholders: Ensure that all stakeholders are aware of the impact of changes on timelines and resources. Regular meetings help in prioritizing changes and setting realistic expectations.
Document Changes: Keep track of changes through version-controlled documentation and issue tracking systems to ensure everyone is informed and no details are missed.
2. Maintaining Code Quality
Challenge: Writing clean, efficient, and maintainable code can be difficult, especially in large projects or when working with a team. Poor code quality leads to technical debt, making the software harder to update and maintain over time.

Strategies:

Enforce Code Reviews: Regular peer reviews help catch issues early and ensure that the code adheres to quality standards. Use tools like GitHub, Bitbucket, or GitLab for code review workflows.
Automate Testing: Implement unit tests, integration tests, and automated code linting to detect errors and enforce coding standards. Continuous Integration (CI) systems can automatically run tests on each commit.
Refactor Regularly: Schedule time for code refactoring to improve structure without changing functionality. Refactoring gradually helps avoid the buildup of technical debt.
3. Balancing Speed and Quality
Challenge: In many projects, there is pressure to deliver software quickly, which can lead to cutting corners, especially in testing and documentation. This trade-off often results in bugs, user dissatisfaction, and costly fixes later.

Strategies:

Set Realistic Deadlines: Work with project managers and stakeholders to establish timelines that allow time for quality control. Pushing back on unrealistic timelines can help balance speed and quality.
Implement Minimum Viable Product (MVP) Approach: Focus on delivering a version with core features first. This allows teams to get user feedback early while still maintaining quality, rather than trying to build a complete product under time pressure.
Continuous Integration/Continuous Deployment (CI/CD): Automating builds, tests, and deployments helps ensure that high-quality code is released quickly without compromising on quality.
4. Keeping Up with New Technologies
Challenge: The technology landscape evolves rapidly, with new languages, frameworks, and tools emerging constantly. Keeping skills up-to-date can be overwhelming but is necessary to remain effective and relevant.

Strategies:

Allocate Time for Learning: Set aside time regularly to learn about new technologies relevant to your field. Many engineers dedicate a few hours weekly or a day monthly for research and upskilling.
Follow Industry Trends: Participate in webinars, conferences, and online courses on sites like Coursera, Udacity, and LinkedIn Learning. Joining developer communities on platforms like GitHub, Stack Overflow, and Reddit also helps.
Experiment with Small Projects: Apply new skills and technologies to side projects or small tasks within your main project. This practical application reinforces learning and helps assess if a tool or technology is valuable.
5. Managing Collaboration and Communication
Challenge: Collaborating across teams, especially in remote or distributed settings, can be challenging. Miscommunication can lead to misunderstandings, project delays, and lower productivity.

Strategies:

Use Collaboration Tools: Tools like Slack, Microsoft Teams, and Zoom facilitate communication. Document shared knowledge using tools like Confluence or Notion to keep everyone aligned.
Conduct Regular Stand-Ups: Daily or weekly stand-up meetings ensure that everyone is updated on project progress, blockers, and priorities.
Encourage Open Communication: Create an environment where team members feel comfortable discussing issues, asking questions, and giving feedback. This fosters trust and reduces the likelihood of misunderstandings.
6. Dealing with Debugging and Problem Solving
Challenge: Debugging complex issues can consume a significant amount of time and resources, especially when issues are difficult to reproduce or trace.

Strategies:

Use Debugging Tools: Leverage IDE-based debugging tools, log analyzers, and monitoring tools like Datadog or New Relic to get insights into system behavior.
Break Down the Problem: Isolate the issue by breaking down the code and using logging statements or smaller tests to narrow down the source.
Adopt Pair Programming: Pair programming can help identify issues more quickly, as a second set of eyes often provides a new perspective on the problem.
7. Handling Work-Life Balance
Challenge: The demands of software engineering, coupled with tight deadlines, can lead to burnout if work-life balance is not carefully managed.

Strategies:

Set Boundaries: Set clear work hours and avoid responding to work messages outside those hours. Communicate your boundaries to your team to avoid unrealistic expectations.
Prioritize Tasks: Use task management tools like Jira or Trello to organize tasks by priority. Completing the most important work first helps reduce stress and manage time effectively.
Take Regular Breaks: Incorporate breaks into your day to recharge. Some engineers use techniques like the Pomodoro technique (25 minutes of focused work followed by a 5-minute break) to maintain productivity.


### Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
.  1. Unit Testing
Definition: Unit testing involves testing individual components or functions of the software in isolation. The primary goal is to validate that each unit of the software code performs as expected.

Importance:

Identifies Bugs Early: By testing the smallest parts of the code individually, unit testing helps identify bugs at the earliest stage of development.
Ensures Code Quality: It promotes good coding practices by requiring code to be modular and testable.
Facilitates Refactoring: Unit tests provide a safety net, allowing developers to refactor or change the codebase with confidence that existing functionality will remain unaffected.
Example: A function that calculates the total price of items in a shopping cart would be tested to ensure it calculates correctly with different numbers and types of items.

2. Integration Testing
Definition: Integration testing checks how different modules or components of the software interact with each other. It’s typically performed after unit testing and ensures that modules work together as intended when integrated.

Importance:

Detects Interface Issues: Integration testing identifies problems in the way components interact, such as mismatched data formats, incorrect data flow, or unexpected dependencies.
Validates Combined Functionality: It ensures that integrated modules provide the expected output, verifying that they work together seamlessly.
Reduces Risks of System Failures: By testing module interactions early, integration testing reduces the risk of major system issues at later stages.
Example: In an e-commerce application, integration testing might verify that the payment gateway module interacts correctly with the order processing system, ensuring that payments and orders are processed without error.

3. System Testing
Definition: System testing is a higher-level test that evaluates the entire system as a whole. It focuses on verifying that all components work together to meet the software’s overall functional and non-functional requirements.

Importance:

Ensures Complete System Functionality: System testing validates the end-to-end functionality of the entire application, ensuring that it meets the specifications and behaves as expected in a real-world environment.
Tests Non-Functional Requirements: It often includes testing non-functional aspects such as performance, security, and usability.
Validates Integrated Systems: System testing evaluates not only the individual modules but the entire system's performance, including its behavior under normal and stress conditions.
Example: In a banking application, system testing would validate the entire workflow of transferring funds, from logging in and selecting accounts to confirming the transfer and updating balances.

4. Acceptance Testing
Definition: Acceptance testing is conducted to verify that the software meets the acceptance criteria set by the stakeholders and is ready for release. This test is typically performed by end-users or stakeholders to confirm that the software works as intended in a real-world scenario.

Importance:

Ensures Customer Satisfaction: Acceptance testing confirms that the software meets the customer’s requirements and expectations, providing assurance that the final product is usable and functional.
Validates Business Requirements: It checks that the software aligns with business goals, often based on specific use cases.
Reduces Post-Release Defects: Acceptance testing helps catch any remaining issues before release, reducing the likelihood of customer-reported defects.
Example: For a mobile banking app, acceptance testing might involve real users verifying that they can perform core tasks, such as checking balances, viewing transaction history, and transferring funds smoothly.

Summary of Importance in Software Quality Assurance
Each type of testing plays a unique role in the QA process:

Unit Testing catches bugs early and ensures code quality at the micro level.
Integration Testing validates that combined modules function as expected.
System Testing evaluates the entire system’s behavior, including both functional and non-functional aspects.
Acceptance Testing provides final validation from the user’s perspective, ensuring the software meets real-world needs and requirements.

# Part 2: Introduction to AI and Prompt Engineering


### Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process of crafting effective, precise inputs, known as prompts, to interact with and optimize the output of AI models. In essence, prompt engineering involves designing instructions, questions, or input text to guide the AI in producing desired responses or performing specific tasks. This approach is particularly crucial for large language models (LLMs), such as OpenAI’s GPT series, where the quality, clarity, and specificity of the prompt directly impact the output’s relevance and accuracy.

Importance of Prompt Engineering in AI Interactions
Improving Response Quality:

Well-designed prompts help obtain more accurate, relevant, and contextually appropriate responses from an AI model. A prompt that lacks specificity or is ambiguous may lead to generic, off-target, or misunderstood responses.
Clear prompts that define the task and provide necessary context improve the coherence, accuracy, and depth of the AI’s output, especially for complex queries.
Reducing Bias and Errors:

Thoughtfully structured prompts can minimize unintended biases by specifying balanced viewpoints or instructing the model to consider different perspectives.
By carefully wording prompts to ask for verifiable information, users can reduce the likelihood of responses based on assumptions or incorrect inferences, leading to more reliable outputs.
Enhancing Task-Specific Performance:

In specialized applications like data analysis, code generation, or content creation, prompt engineering helps align the AI’s output with the task's requirements. For instance, prompts that set a formal tone for business content or specify technical jargon for medical writing make the AI’s output more suitable for its intended audience or purpose.
For code generation, specifying languages, functions, and libraries in prompts can help the AI provide more targeted and practical solutions.
Optimizing Workflow Efficiency:

Effective prompt engineering can streamline workflows by getting desired results faster and with fewer iterations. Instead of trial-and-error prompting, carefully crafted initial inputs save time and reduce the need for edits or additional clarifications.
This is especially important in enterprise settings where AI models are used to automate processes, generate insights, or assist in customer service, where prompt precision directly affects productivity and consistency.
Facilitating Model Capabilities Exploration:

Prompt engineering allows users to uncover the full potential of AI models by testing the effects of different prompt structures, which can lead to new, innovative uses of the model.
Experimenting with varied prompt formats, such as asking for lists, summaries, comparisons, or specific tones, reveals the versatility of the AI model and can lead to new applications in fields like education, marketing, and software development.
Controlling Tone and Style:

Prompts can instruct models to adopt specific tones, styles, or levels of formality, which is invaluable for tasks ranging from technical writing to casual conversation or creative storytelling.
In customer service applications, for example, prompt engineering ensures that the AI’s responses align with a brand’s voice, which is key to maintaining a consistent customer experience.
Examples of Prompt Engineering in Practice
Clarifying a Task: Instead of asking, “Tell me about AI,” a refined prompt might say, “Explain how AI impacts healthcare, focusing on patient diagnostics and personalized medicine, in two paragraphs.”
Setting Constraints: For a programming request, a user might specify, “Write a Python script that calculates compound interest, including user input for the principal, rate, and time.”
Exploring Tone Variance: To get a formal response, one could prompt, “Explain blockchain technology in a formal tone suitable for a business report,” versus a more casual, conversational approach.

### Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
. Vague Prompt Example:
"Tell me about climate change."

Improved Prompt:
"Summarize the main causes and effects of climate change on global weather patterns in three paragraphs, including recent examples."

Explanation of Improvement:
The improved prompt is clearer, more specific, and concise for several reasons:

Defines Scope: It specifies that the response should cover both causes and effects, narrowing the focus and making it clear what information is needed.

Sets Length Constraints: By requesting "three paragraphs," the prompt sets an expectation for the amount of detail, which helps the AI produce a concise, manageable response rather than overwhelming or incomplete information.

Specifies Context: Adding “on global weather patterns” narrows the subject within the broader topic of climate change, allowing the AI to provide a targeted response rather than a general overview.

Requests Recent Examples: Including “recent examples” guides the AI to include current information, making the response more relevant and practical.